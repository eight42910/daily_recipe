# AI × React ハンズオンガイド（daily_recipe）

このドキュメントは「AI に質問しながら、実際に手を動かして理解を深める」ための最小ステップをまとめたものです。開発サーバーを起動し、UI の挙動を目で追いながら、意図的にコードを崩して戻す練習を通じて、React の状態更新・レンダー・キーの概念を体感します。

## 事前準備

- Node.js と npm がインストールされていること（macOS / zsh）。
- このリポジトリのルート `/Users/EIGHT/repository/daily_recipe` で以下を実行：

```zsh
npm install
npm run dev
```

- ブラウザで表示し、変更を保存すると即時反映される状態にしておく（Vite の HMR）。

## 進め方の全体像（AI の使い方）

- 小さく変更 → 画面で挙動確認 → 疑問点を AI に投げる → さらに小さく修正、のループ。
- 質問は「具体のコード・スクショ・現象」を添えると回答の精度が上がる。
- 迷ったら「今の目的」「変えたコード」「期待と実際の差」を 3 点セットで AI に渡す。

## ハンズオン課題（UI で体感する）

以下は `src/components/RecipeForm.jsx` と `src/components/RecipeList.jsx` / `src/components/RecipeItem.jsx`、そして `src/App.jsx` を中心に触りながら確認します。

### 1. 追加・削除の基本挙動を目で追う

- 開発サーバーを起動したまま、フォームからレシピを追加。
- 追加したアイテムが「先頭」に出る仕様かを確認（現在の実装に依存）。
- 削除ボタンで消えるかを確認。UI 変化を目で追うのが一番早い。

質問例（AI 向け）：

- 「追加したら末尾に出るようにしたい。どこを変えれば良い？」
- 「削除時に確認ダイアログを挟みたい。`confirm` の正しい使い方は？」

### 2. 配列更新をあえて mutate して差を体感

- `App.jsx`（または状態を持つコンポーネント）の追加ロジックで、わざとミュータブル更新に変更：

```js
// NG例：ミュータブル更新（体験用）
setRecipes((prev) => {
  prev.push(newRecipe);
  return prev; // 同じ配列参照を返す
});
```

- 画面が更新されない／レンダーが崩れることがあるのを観察。
- 終わったら必ず「イミュータブル更新」に戻す：

```js
// OK例：イミュータブル更新
setRecipes((prev) => [newRecipe, ...prev]);
// または  [...prev, newRecipe]（並びを末尾に追加）
```

ポイント：配列の「参照」が新規になるかが React の差分検出に重要。

### 3. console.log で before/after を覗く

- 追加・削除ハンドラの冒頭で：

```js
console.log("before", recipes);
```

- `setRecipes` のアップデータ関数内で：

```js
setRecipes((prev) => {
  const next = [newRecipe, ...prev];
  console.log("after", next);
  return next;
});
```

- ログを見て「新しい配列参照」になっているか、要素の増減が期待通りかを確認。

### 4. key と `crypto.randomUUID()` を体感

- 追加/削除を連打して、各アイテムの `id` がユニークに増えていくことを確認。
- `RecipeList.jsx`（または `RecipeItem.jsx` のリストレンダー）で `key={recipe.id}` が使われているか確認。
- React DevTools を開き、要素ツリーで key の変化と差分適用を観察。

質問例：

- 「key にインデックスを使うと何が問題？」
- 「`crypto.randomUUID()` を使うタイミングはどこが安全？」

### 5. confirm を外して UX を手で確かめる

- 削除処理で一時的に `confirm` を外して即削除に変更。
- 誤タップしやすさを感じたら、`confirm` を戻す。
- 「UX の体感 → 仕様に反映」の流れを経験する。

### 6. 並び順を変更して仕様 →UI の一致を確認

- 追加時の更新を `setRecipes((prev) => [...prev, newRecipe])` に変更して、並びが末尾追加になることを確認。
- 逆に `setRecipes((prev) => [newRecipe, ...prev])` にすると先頭追加になることを確認。
- 「仕様が UI にどう現れるか」を意識して、想定と違えば修正。

### 7. 「意図的に崩して戻す」練習のテンプレ

- 手順：

  1. 現状の挙動を把握（ログ・UI）。
  2. あえて崩す（mutate、key を変える、confirm を外す、順序を変える）。
  3. 何が起きるかを観察（レンダー、ログ、DevTools）。
  4. 元に戻す（イミュータブル、安定 key、必要な UX）。
  5. 学びを短くメモし、AI に補足質問。

- 目的：なぜその書き方が必要か、身体で覚える。

## よくある落とし穴とチェックリスト

- 状態更新で同じ参照を返していないか？（配列・オブジェクトのイミュータブル）
- key が安定しているか？（`id` を使い、インデックスは避ける）
- ハンドラ内で最新の状態に依存するなら関数型 `setState` を使っているか？
- フォーム入力の制御（Controlled Components）が崩れていないか？
- `console.log` を適所で仕込んで観察しているか？

## AI に投げると良い具体例

- 「この `handleAdd` をイミュータブルに書き直して。今はこう：<コード抜粋>」
- 「削除時に `confirm` を入れて、テスト用にモックするには？」
- 「DevTools で key の変化がこう見えた。この挙動の理由は？」
- 「`useEffect` で保存（Phase-04）に進めたい。最小コード例を。」

## 次の段階（docs/phase-\* への橋渡し）

- Phase-01（最小機能）で追加・削除・表示の正しさを体感。
- Phase-02（詳細・バリデーション）でフォーム検証・エラーハンドリングへ。
- Phase-03（検索・フィルタ・ソート）で状態設計の幅を拡張。
- Phase-04（永続化）で `localStorage` 保存や読み込みを追加。
- Phase-05（ルーティング）で画面分割と URL 設計。
- Phase-06（リファクタ・テスト）で安定化。

---

必要なら、このドキュメントの各セクションをベースに、AI に「この手順をコードに落として」と依頼してください。短く具体的に依頼するほど、AI は正確に支援できます。
